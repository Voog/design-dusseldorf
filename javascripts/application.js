// quantize.js, Copyright 2012 Shao-Chung Chen.
// Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)

// Basic CoffeeScript port of the (MMCQ) Modified Media Cut Quantization
// algorithm from the Leptonica library (http://www.leptonica.com/).
// Return a color map you can use to map original pixels to the reduced palette.
//
// Rewritten from the JavaScript port (http://gist.github.com/1104622)
// developed by Nick Rabinowitz under the MIT license.

// Generated by CoffeeScript 1.3.3
var MMCQ, PriorityQueue;

PriorityQueue = (function() {

  function PriorityQueue(comparator) {
    this.comparator = comparator;
    this.contents = [];
    this.sorted = false;
  }

  PriorityQueue.prototype.sort = function() {
    this.contents.sort(this.comparator);
    return this.sotred = true;
  };

  PriorityQueue.prototype.push = function(obj) {
    this.contents.push(obj);
    return this.sorted = false;
  };

  PriorityQueue.prototype.peek = function(index) {
    if (index == null) {
      index = this.contents.length - 1;
    }
    if (!this.sorted) {
      this.sort();
    }
    return this.contents[index];
  };

  PriorityQueue.prototype.pop = function() {
    if (!this.sorted) {
      this.sort();
    }
    return this.contents.pop();
  };

  PriorityQueue.prototype.size = function() {
    return this.contents.length;
  };

  PriorityQueue.prototype.map = function(func) {
    return this.contents.map(func);
  };

  return PriorityQueue;

})();

MMCQ = (function() {
  var ColorBox, ColorMap, cboxFromPixels, getColorIndex, getHisto, medianCutApply,
    _this = this;

  MMCQ.sigbits = 5;

  MMCQ.rshift = 8 - MMCQ.sigbits;

  function MMCQ() {
    this.maxIterations = 1000;
    this.fractByPopulations = 0.75;
  }

  getColorIndex = function(r, g, b) {
    return (r << (2 * MMCQ.sigbits)) + (g << MMCQ.sigbits) + b;
  };

  ColorBox = (function() {

    function ColorBox(r1, r2, g1, g2, b1, b2, histo) {
      this.r1 = r1;
      this.r2 = r2;
      this.g1 = g1;
      this.g2 = g2;
      this.b1 = b1;
      this.b2 = b2;
      this.histo = histo;
    }

    ColorBox.prototype.volume = function(forced) {
      if (!this._volume || forced) {
        this._volume = (this.r2 - this.r1 + 1) * (this.g2 - this.g1 + 1) * (this.b2 - this.b1 + 1);
      }
      return this._volume;
    };

    ColorBox.prototype.count = function(forced) {
      var b, g, index, numpix, r, _i, _j, _k, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      if (!this._count_set || forced) {
        numpix = 0;
        for (r = _i = _ref = this.r1, _ref1 = this.r2; _i <= _ref1; r = _i += 1) {
          for (g = _j = _ref2 = this.g1, _ref3 = this.g2; _j <= _ref3; g = _j += 1) {
            for (b = _k = _ref4 = this.b1, _ref5 = this.b2; _k <= _ref5; b = _k += 1) {
              index = getColorIndex(r, g, b);
              numpix += this.histo[index] || 0;
            }
          }
        }
        this._count_set = true;
        this._count = numpix;
      }
      return this._count;
    };

    ColorBox.prototype.copy = function() {
      return new ColorBox(this.r1, this.r2, this.g1, this.g2, this.b1, this.b2, this.histo);
    };

    ColorBox.prototype.average = function(forced) {
      var b, bsum, g, gsum, hval, index, mult, r, rsum, total, _i, _j, _k, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      if (!this._average || forced) {
        mult = 1 << (8 - MMCQ.sigbits);
        total = 0;
        rsum = 0;
        gsum = 0;
        bsum = 0;
        for (r = _i = _ref = this.r1, _ref1 = this.r2; _i <= _ref1; r = _i += 1) {
          for (g = _j = _ref2 = this.g1, _ref3 = this.g2; _j <= _ref3; g = _j += 1) {
            for (b = _k = _ref4 = this.b1, _ref5 = this.b2; _k <= _ref5; b = _k += 1) {
              index = getColorIndex(r, g, b);
              hval = this.histo[index] || 0;
              total += hval;
              rsum += hval * (r + 0.5) * mult;
              gsum += hval * (g + 0.5) * mult;
              bsum += hval * (b + 0.5) * mult;
            }
          }
        }
        if (total) {
          this._average = [~~(rsum / total), ~~(gsum / total), ~~(bsum / total)];
        } else {
          this._average = [~~(mult * (this.r1 + this.r2 + 1) / 2), ~~(mult * (this.g1 + this.g2 + 1) / 2), ~~(mult * (this.b1 + this.b2 + 1) / 2)];
        }
      }
      return this._average;
    };

    ColorBox.prototype.contains = function(pixel) {
      var b, g, r;
      r = pixel[0] >> MMCQ.rshift;
      g = pixel[1] >> MMCQ.rshift;
      b = pixel[2] >> MMCQ.rshift;
      return ((this.r1 <= r && r <= this.r2)) && ((this.g1 <= g && g <= this.g2)) && ((this.b1 <= b && b <= this.b2));
    };

    return ColorBox;

  })();

  ColorMap = (function() {

    function ColorMap() {
      this.cboxes = new PriorityQueue(function(a, b) {
        var va, vb;
        va = a.count() * a.volume();
        vb = b.count() * b.volume();
        if (va > vb) {
          return 1;
        } else if (va < vb) {
          return -1;
        } else {
          return 0;
        }
      });
    }

    ColorMap.prototype.push = function(cbox) {
      return this.cboxes.push({
        cbox: cbox,
        color: cbox.average()
      });
    };

    ColorMap.prototype.palette = function() {
      return this.cboxes.map(function(cbox) {
        return cbox.color;
      });
    };

    ColorMap.prototype.size = function() {
      return this.cboxes.size();
    };

    ColorMap.prototype.map = function(color) {
      var i, _i, _ref;
      for (i = _i = 0, _ref = this.cboxes.size(); _i < _ref; i = _i += 1) {
        if (this.cboxes.peek(i).cbox.contains(color)) {
          return this.cboxes.peek(i).color;
        }
        return this.nearest(color);
      }
    };

    ColorMap.prototype.cboxes = function() {
      return this.cboxes;
    };

    ColorMap.prototype.nearest = function(color) {
      var dist, i, minDist, retColor, square, _i, _ref;
      square = function(n) {
        return n * n;
      };
      minDist = 1e9;
      for (i = _i = 0, _ref = this.cboxes.size(); _i < _ref; i = _i += 1) {
        dist = Math.sqrt(square(color[0] - this.cboxes.peek(i).color[0]) + square(color[1] - this.cboxes.peek(i).color[1]) + square(color[2] - this.cboxes.peek(i).color[2]));
        if (dist < minDist) {
          minDist = dist;
          retColor = this.cboxes.peek(i).color;
        }
      }
      return retColor;
    };

    return ColorMap;

  })();

  getHisto = function(pixels) {
    var b, g, histo, histosize, index, pixel, r, _i, _len;
    histosize = 1 << (3 * MMCQ.sigbits);
    histo = new Array(histosize);
    for (_i = 0, _len = pixels.length; _i < _len; _i++) {
      pixel = pixels[_i];
      r = pixel[0] >> MMCQ.rshift;
      g = pixel[1] >> MMCQ.rshift;
      b = pixel[2] >> MMCQ.rshift;
      index = getColorIndex(r, g, b);
      histo[index] = (histo[index] || 0) + 1;
    }
    return histo;
  };

  cboxFromPixels = function(pixels, histo) {
    var b, bmax, bmin, g, gmax, gmin, pixel, r, rmax, rmin, _i, _len;
    rmin = 1e6;
    rmax = 0;
    gmin = 1e6;
    gmax = 0;
    bmin = 1e6;
    bmax = 0;
    for (_i = 0, _len = pixels.length; _i < _len; _i++) {
      pixel = pixels[_i];
      r = pixel[0] >> MMCQ.rshift;
      g = pixel[1] >> MMCQ.rshift;
      b = pixel[2] >> MMCQ.rshift;
      if (r < rmin) {
        rmin = r;
      } else if (r > rmax) {
        rmax = r;
      }
      if (g < gmin) {
        gmin = g;
      } else if (g > gmax) {
        gmax = g;
      }
      if (b < bmin) {
        bmin = b;
      } else if (b > bmax) {
        bmax = b;
      }
    }
    return new ColorBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);
  };

  medianCutApply = function(histo, cbox) {
    var b, bw, doCut, g, gw, index, lookaheadsum, maxw, partialsum, r, rw, sum, total, _i, _j, _k, _l, _m, _n, _o, _p, _q, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    if (!cbox.count()) {
      return;
    }
    if (cbox.count() === 1) {
      return [cbox.copy()];
    }
    rw = cbox.r2 - cbox.r1 + 1;
    gw = cbox.g2 - cbox.g1 + 1;
    bw = cbox.b2 - cbox.b1 + 1;
    maxw = Math.max(rw, gw, bw);
    total = 0;
    partialsum = [];
    lookaheadsum = [];
    if (maxw === rw) {
      for (r = _i = _ref = cbox.r1, _ref1 = cbox.r2; _i <= _ref1; r = _i += 1) {
        sum = 0;
        for (g = _j = _ref2 = cbox.g1, _ref3 = cbox.g2; _j <= _ref3; g = _j += 1) {
          for (b = _k = _ref4 = cbox.b1, _ref5 = cbox.b2; _k <= _ref5; b = _k += 1) {
            index = getColorIndex(r, g, b);
            sum += histo[index] || 0;
          }
        }
        total += sum;
        partialsum[r] = total;
      }
    } else if (maxw === gw) {
      for (g = _l = _ref6 = cbox.g1, _ref7 = cbox.g2; _l <= _ref7; g = _l += 1) {
        sum = 0;
        for (r = _m = _ref8 = cbox.r1, _ref9 = cbox.r2; _m <= _ref9; r = _m += 1) {
          for (b = _n = _ref10 = cbox.b1, _ref11 = cbox.b2; _n <= _ref11; b = _n += 1) {
            index = getColorIndex(r, g, b);
            sum += histo[index] || 0;
          }
        }
        total += sum;
        partialsum[g] = total;
      }
    } else {
      for (b = _o = _ref12 = cbox.b1, _ref13 = cbox.b2; _o <= _ref13; b = _o += 1) {
        sum = 0;
        for (r = _p = _ref14 = cbox.r1, _ref15 = cbox.r2; _p <= _ref15; r = _p += 1) {
          for (g = _q = _ref16 = cbox.g1, _ref17 = cbox.g2; _q <= _ref17; g = _q += 1) {
            index = getColorIndex(r, g, b);
            sum += histo[index] || 0;
          }
        }
        total += sum;
        partialsum[b] = total;
      }
    }
    partialsum.forEach(function(d, i) {
      return lookaheadsum[i] = total - d;
    });
    doCut = function(color) {
      var cbox1, cbox2, count2, d2, dim1, dim2, i, left, right, _r, _ref18, _ref19;
      dim1 = color + '1';
      dim2 = color + '2';
      for (i = _r = _ref18 = cbox[dim1], _ref19 = cbox[dim2]; _r <= _ref19; i = _r += 1) {
        if (partialsum[i] > (total / 2)) {
          cbox1 = cbox.copy();
          cbox2 = cbox.copy();
          left = i - cbox[dim1];
          right = cbox[dim2] - i;
          if (left <= right) {
            d2 = Math.min(cbox[dim2] - 1, ~~(i + right / 2));
          } else {
            d2 = Math.max(cbox[dim1], ~~(i - 1 - left / 2));
          }
          while (!partialsum[d2]) {
            d2++;
          }
          count2 = lookaheadsum[d2];
          while (!count2 && partialsum[d2 - 1]) {
            count2 = lookaheadsum[--d2];
          }
          cbox1[dim2] = d2;
          cbox2[dim1] = cbox1[dim2] + 1;
          // console.log("cbox counts: " + (cbox.count()) + ", " + (cbox1.count()) + ", " + (cbox2.count()));
          return [cbox1, cbox2];
        }
      }
    };
    if (maxw === rw) {
      return doCut("r");
    }
    if (maxw === gw) {
      return doCut("g");
    }
    if (maxw === bw) {
      return doCut("b");
    }
  };

  MMCQ.prototype.quantize = function(pixels, maxcolors) {
    var cbox, cmap, histo, iter, pq, pq2,
      _this = this;
    if ((!pixels.length) || (maxcolors < 2) || (maxcolors > 256)) {
      console.log("invalid arguments");
      return false;
    }
    histo = getHisto(pixels);
    cbox = cboxFromPixels(pixels, histo);
    pq = new PriorityQueue(function(a, b) {
      var va, vb;
      va = a.count();
      vb = b.count();
      if (va > vb) {
        return 1;
      } else if (va < vb) {
        return -1;
      } else {
        return 0;
      }
    });
    pq.push(cbox);
    iter = function(lh, target) {
      var cbox1, cbox2, cboxes, ncolors, niters;
      ncolors = 1;
      niters = 0;
      while (niters < _this.maxIterations) {
        cbox = lh.pop();
        if (!cbox.count()) {
          lh.push(cbox);
          niters++;
          continue;
        }
        cboxes = medianCutApply(histo, cbox);
        cbox1 = cboxes[0];
        cbox2 = cboxes[1];
        if (!cbox1) {
          console.log("cbox1 not defined; shouldn't happen");
          return;
        }
        lh.push(cbox1);
        if (cbox2) {
          lh.push(cbox2);
          ncolors++;
        }
        if (ncolors >= target) {
          return;
        }
        if ((niters++) > _this.maxIterations) {
          console.log("infinite loop; perhaps too few pixels");
          return;
        }
      }
    };
    iter(pq, this.fractByPopulations * maxcolors);
    pq2 = new PriorityQueue(function(a, b) {
      var va, vb;
      va = a.count() * a.volume();
      vb = b.count() * b.volume();
      if (va > vb) {
        return 1;
      } else if (va < vb) {
        return -1;
      } else {
        return 0;
      }
    });
    while (pq.size()) {
      pq2.push(pq.pop());
    }
    iter(pq2, maxcolors - pq2.size());
    cmap = new ColorMap;
    while (pq2.size()) {
      cmap.push(pq2.pop());
    }
    return cmap;
  };

  return MMCQ;

}).call(this);

// Generated by CoffeeScript 1.6.3
(function() {
  window.ColorExtract = (function() {
    function ColorExtract() {}

    ColorExtract.getColorMap = function(canvas, sx, sy, w, h, nc) {
      var index, indexBase, pdata, pixels, x, y, _i, _j, _ref, _ref1;
      if (nc == null) {
        nc = 8;
      }
      pdata = canvas.getContext("2d").getImageData(sx, sy, w, h).data;
      pixels = [];
      for (y = _i = sy, _ref = sy + h; _i < _ref; y = _i += 1) {
        indexBase = y * w * 4;
        for (x = _j = sx, _ref1 = sx + w; _j < _ref1; x = _j += 1) {
          index = indexBase + (x * 4);
          pixels.push([pdata[index], pdata[index + 1], pdata[index + 2]]);
        }
      }
      return (new MMCQ).quantize(pixels, nc);
    };

    ColorExtract.colorDist = function(a, b) {
      var square;
      square = function(n) {
        return n * n;
      };
      return square(a[0] - b[0]) + square(a[1] - b[1]) + square(a[2] - b[2]);
    };

    ColorExtract.extract = function(image, canvas, callback) {
      var bgColor, bgColorMap, bgPalette, color, dist, fgColor, fgColor2, fgColorMap, fgPalette, maxDist, rgbToCssString, _i, _j, _len, _len1;
      canvas.width = 25;
      canvas.height = 25;
      canvas.getContext("2d").drawImage(image, 0, 0, canvas.width, canvas.height);
      bgColorMap = ColorExtract.getColorMap(canvas, 0, 0, canvas.width, canvas.height, 4);
      bgPalette = bgColorMap.cboxes.map(function(cbox) {
        return {
          count: cbox.cbox.count(),
          rgb: cbox.color
        };
      });
      bgPalette.sort(function(a, b) {
        return b.count - a.count;
      });
      bgColor = bgPalette[0].rgb;
      fgColorMap = ColorExtract.getColorMap(canvas, 0, 0, image.width, image.height, 10);
      fgPalette = fgColorMap.cboxes.map(function(cbox) {
        return {
          count: cbox.cbox.count(),
          rgb: cbox.color
        };
      });
      fgPalette.sort(function(a, b) {
        return b.count - a.count;
      });
      maxDist = 0;
      for (_i = 0, _len = fgPalette.length; _i < _len; _i++) {
        color = fgPalette[_i];
        dist = ColorExtract.colorDist(bgColor, color.rgb);
        if (dist > maxDist) {
          maxDist = dist;
          fgColor = color.rgb;
        }
      }
      maxDist = 0;
      for (_j = 0, _len1 = fgPalette.length; _j < _len1; _j++) {
        color = fgPalette[_j];
        dist = ColorExtract.colorDist(bgColor, color.rgb);
        if (dist > maxDist && color.rgb !== fgColor) {
          maxDist = dist;
          fgColor2 = color.rgb;
        }
      }
      rgbToCssString = function(color) {
        return "rgb(" + color[0] + ", " + color[1] + ", " + color[2] + ")";
      };
      return callback({
        bgColor: rgbToCssString(bgColor),
        fgColor: rgbToCssString(fgColor),
        fgColor2: rgbToCssString(fgColor2)
      });
    };

    return ColorExtract;

  })();

}).call(this);

;
(function ($) {

  $(function () {
    // Function to limit the rate at which a function can fire.
    var debounce = function (func, wait, immediate) {
      var timeout;
      return function () {
        var context = this,
          args = arguments;
        var later = function () {
          timeout = null;
          if (!immediate) func.apply(context, args);
        };
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) func.apply(context, args);
      };
    };

    $('.js-popup-menu').jsPopupMenu();

    if ($('html').hasClass('no-placeholder')) {
      $('input[type="text"],textarea').each(function () {
        if ($(this).attr('placeholder') && !$(this).val()) {
          $(this).val($(this).attr('placeholder'));
        }
        $(this).focus(function () {
          if ($(this).val() == $(this).attr('placeholder')) {
            $(this).val('');
          }
        }).blur(function () {
          if (!$(this).val() && $(this).attr('placeholder')) {
            $(this).val($(this).attr('placeholder'));
          }
        });
      });
    }

    $('.form_fields:not(.edy-fe-fields) select, .custom-select').jqSelect();

    $('body:not(.editmode) table').each(function () {
      $(this).wrap('<div class="table-holder" />');
    });

    $('.mobile-menu-toggler').click(function (event) {
      event.preventDefault();
      $('body').toggleClass('mobilemenu-open');
      $('body').removeClass('mobilesearch-open');

      $('.edy-ecommerce-shopping-cart-button').hide();
    });

    $('.mobile-menu-close').on('click', function (event) {
      event.preventDefault();

      if ($('body').hasClass('language-menu-open')) {
        $('body').removeClass('language-menu-open');
      } else {
        $('body').removeClass('mobilemenu-open');
      }

      if ($('.edy-ecommerce-shopping-cart-button').length > 0) {
        $('body').addClass('edy-checkout-button-visible');
        $('.edy-ecommerce-shopping-cart-button').show();
      }
    });


    $('.language-menu-btn').on('click', function (event) {
      event.preventDefault();
      $('body').addClass('language-menu-open');
    });

    $('.comment-form-focus-input').focus(function () {
      var $el = $(this).hide();
      $(this).closest('.comment-form').find('.form_area').show().find('textarea').focus();
      setCommonContent();
    });

    if ($('body').hasClass('front-page')) {
      setFrontContent();
      $(window).resize(debounce(setFrontContent, 100));

      // In edit mode maintain column equilibrium while user inputs new data
      var delay = (function () {
        var timer = 0;
        return function (callback, ms) {
          clearTimeout(timer);
          timer = setTimeout(callback, ms);
        };
      })();

    }

    if (!$('body').hasClass('front-page')) {
      setCommonContent();
      $(window).resize(debounce(setCommonContent, 100));
    }

    if ($('.comment-form').hasClass('form_with_errors')) {
      $('html, body').scrollTop($('.comment-form').offset().top);
    } else if ($('form').find('.form_error, .form_notice').length > 0) {
      $('html, body').scrollTop($('.form_error, .form_notice').closest('form').offset().top);
    }
  });

  var setFrontContent = function () {
    $('.main-menu').removeAttr("style");
    $('.header-row .content-full').removeAttr("style");
    $('.center-row .content-inner').removeAttr("style");
    $('.center-row .content-inner .inner-bottom').removeAttr("style");

    // Set header row height, to bypass vh rounding issue
    var whHeaderFullCalc = Math.round($(window).height() * (0.31)),
      whHeaderFullTarget = $('.header-row .content-full').css('min-height', whHeaderFullCalc);

    var whViewport = $(window).height(),
      whDocument = $(document).height(),
      whTopbar = $('.topbar').height(),
      whHeader = $('.header-row').height(),
      whCenter = $('.center-row').height(),
      whFooter = $('.footer-row').height();

    var whCentInnerPad = parseInt($('.center-row .inner-padding').css('padding-top')) * 2,
      whBodyFootRem = whDocument - whFooter - whHeader - whCentInnerPad;

    var whColUnder = whDocument - whHeader - whCenter - whFooter,
      whColUnderTarget = whDocument - whHeader - whCenter - whFooter - whTopbar;

    // Adjust center row inner-padding with min-height to make sure viewport is always filled with content
    if ($(document).width() >= 1024) {

      // Calc for center row padding, to fill viewport with content areas
      if (!$('html').hasClass('editmode')) {
        var whCenterInnerTarget = $('.center-row .content-inner').css('min-height', whBodyFootRem);
      } else {
        var whEdy = $('#edy-bar').height(),
          whBodyFootRemEdy = whBodyFootRem - whEdy,
          whCenterInnerTarget = $('.center-row .content-inner').css('min-height', whBodyFootRem);
      };

      var contLeft = $('.content-left .content-inner').height(),
        contRight = $('.content-right .content-inner').height(),
        contLeftBottom = $('.content-left .content-inner .inner-bottom').height(),
        contRightBottom = $('.content-right .content-inner .inner-bottom').height();

      // Remove inner-bottom absolute value, if user content needs to expand the parent container
      if (contLeft < contLeftBottom) {
        $('.center-row .content-left .inner-bottom').css("position", "relative");
      };
      if (contRight < contRightBottom) {
        $('.center-row .content-right .inner-bottom').css("position", "relative");
      };

      // Equalize center-row left and right half content columns
      var whLeft = $('.content-left .content-inner').height(),
        whRight = $('.content-right .content-inner').height();

      if (whLeft > whRight) {
        var targetCalc = whLeft;
        $('.center-row .content-inner').css('min-height', targetCalc);

      };
      if (whLeft < whRight) {
        var targetCalc = whRight;
        $('.center-row .content-inner').css('min-height', targetCalc);
      };

    };

    // Make content areas play nice with long sidebars on smaller than 1024px screens
    if (whColUnder > 0 && $(document).width() < 1024) {
      var whColUnderCalc = whColUnderTarget + $('.content-left .content-inner').height(),
        whColUnderCenterInnerTarget = $('.content-left .content-inner').css('min-height', whColUnderCalc);
    };

    if ($(document).width() < 1024) {
      var contLeft = $('.content-left .content-inner').height(),
        contRight = $('.content-right .content-inner').height(),
        contLeftBottom = $('.content-left .content-inner .inner-bottom').height(),
        contRightBottom = $('.content-right .content-inner .inner-bottom').height();

      // Remove inner-bottom absolute value, if user content needs to expand the parent container
      if (contLeft < contLeftBottom) {
        $('.center-row .content-left .inner-bottom').css("position", "relative");
      };
      if (contRight < contRightBottom) {
        $('.center-row .content-right .inner-bottom').css("position", "relative");
      };
    };

  };

  var setCommonContent = function () {
    if ($(window).width() > 600) {
      var padSidebar = parseInt($('.sidebar-inner').css('padding-bottom')),
        whSideFooter = $('.main > footer').height();

      if (padSidebar < whSideFooter) {
        var padSidebarTarget = $('.sidebar-inner').css('padding-bottom', whSideFooter);
      }

      $('.js-content-top').removeAttr("style");
      var commonDoc = $(document).height(),
        commonConTop = $('.js-content-top').height();

      if (commonConTop < commonDoc) {
        var commonConTopTarget = $('.js-content-top').css('min-height', commonDoc);
      }
    } else {
      $('.js-content-top').css('min-height', 0);
    }
  };



})(jQuery);


(function ($) {
  $.fn.extend({
    jsPopupMenu: function (options) {
      this.each(function () {
        var $menu = $(this),
          $btn = $menu.find('.js-popup-menu-btn'),
          $pop = $menu.find('.js-popup-menu-popover');

        $pop.hide();
        $btn.on('click', function (event) {
          event.preventDefault();
          if ($pop.is(':hidden')) {
            $pop.show();
            $btn.addClass('open');

            setTimeout(function () {
              $(document).on('click.js-popup-menu-click', function () {
                $pop.hide();
                $btn.removeClass('open');
                $(this).off('.js-popup-menu-click');
              });
            }, 0);

          }
        });
      });
      return this;
    }
  });

})(jQuery);

(function ($) {
  $.jquerySelect = function () {

    return {
      init: function ($elem, settings) {
        $elem.wrap('<div class="jq-select" />');

        var $holder = $elem.parent(),
          $arrow = $('<div class="jq-select-arrow"></div>'),
          $content = $('<div class="jq-select-content" />'),
          $inner = $('<div class="jq-select-inner" />').text($elem.children(':selected').text());

        $content.append($inner);
        $holder.append($content);
        $holder.append($arrow);

        if ($elem.hasClass('form_field_size_large')) {
          $elem.removeClass('form_field_size_large');
          $holder.addClass('form_field_size_large');
        } else if ($elem.hasClass('form_field_size_medium')) {
          $elem.removeClass('form_field_size_medium');
          $holder.addClass('form_field_size_medium');
        } else if ($elem.hasClass('form_field_size_small')) {
          $elem.removeClass('form_field_size_small');
          $holder.addClass('form_field_size_small');
        } else {
          $holder.addClass('form_field_size_small');
        }

        $elem.change($.proxy(function () {
          $inner.text($elem.children(':selected').text());
        }, this));

        $elem.keyup($.proxy(function () {
          $inner.text($elem.children(':selected').text());
        }, this));

        $elem.bind('update', $.proxy(function () {
          $inner.text($elem.children(':selected').text());
        }, this));
      }
    };
  }();

  $.fn.extend({
    jqSelect: function (options) {
      this.each(function () {
        var settings = $.extend({}, options);
        $.jquerySelect.init($(this), settings);
      });
      return this;
    }
  });

})(jQuery);

(function ($) {

  var articlePage = $('body').hasClass('blog-article-page');

  // contentHalf background image and color preview logic function.
  var contentHalfBgPreview = function (data, contentHalf, contentHalfObj) {

    // Returns the suitable version of the image depending on the viewport width.
    var getImageByWidth = function (sizes, targetWidth) {
      var prevImage;
      for (var i = 0, max = sizes.length; i < max; i++) {
        if (sizes[i].width < targetWidth) {
          return prevImage || sizes[i];
        }
        prevImage = sizes[i];
      }
      // Makes sure that smallest is returned if all images bigger than targetWidth.
      return sizes[sizes.length - 1];
    };

    var contentHalfBgImageSizesContains = function (sizes, url) {
      for (var i = sizes.length; i--;) {
        if (url.indexOf(sizes[i].url.trim()) > -1) {
          return true;
        }
      }
      return false;
    };

    // Checks the lightness sum of header background image and color and sets the lightness class depending on it's value.
    var handleContentHalfImageLightnessClass = function () {
      if (contentHalfBgCombinedLightness >= 0.5) {
        $(contentHalf).find('.js-background-type').addClass('light-background').removeClass('dark-background');
      } else {
        $(contentHalf).find('.js-background-type').addClass('dark-background').removeClass('light-background');
      }
    };

    // Defines the suitable image based on the viewport width.
    var suitableImage = data.imageSizes ? getImageByWidth(data.imageSizes, $(window).width()) : 'none';

    // Defines the variables used in preview logic.
    var contentHalfBgImagePrevious = $(contentHalf).css('background-image'),
      contentHalfBgImage = (data.image && data.image !== '') ? 'url(' + suitableImage.url + ')' : 'none',
      contentHalfBgImageSizes = (data.imageSizes && data.imageSizes !== '') ? data.imageSizes : null,
      contentHalfBgColor = (data.color && data.color !== '') ? data.color : 'rgba(0,0,0,0)',
      contentHalfBgColorOpacity = (data.colorData && data.colorData !== '') ? data.colorData.a : 'none',
      contentHalfBgColorLightness = (data.colorData && data.colorData !== '') ? data.colorData.lightness : 1,
      colorExtractImage = $('<img>'),
      colorExtractCanvas = $('<canvas>'),
      colorExtractImageUrl = (data.image && data.image !== '') ? data.image : null;

    if (colorExtractImageUrl) {
      if (contentHalfBgImageSizesContains(contentHalfBgImageSizes, contentHalfBgImagePrevious)) {
        contentHalfBgCombinedLightness = getCombinedLightness(contentHalfObj.contentHalfBgImageColor, contentHalfBgColor);
        handleContentHalfImageLightnessClass();
      } else {
        colorExtractImage.attr('src', colorExtractImageUrl.replace(/.*\/(photos|voogstock)/g, '/photos'));
        colorExtractImage.on('load', function () {
          ColorExtract.extract(colorExtractImage[0], colorExtractCanvas[0], function (data) {
            contentHalfObj.contentHalfBgImageColor = data.bgColor ? data.bgColor : 'rgba(255,255,255,1)';
            contentHalfBgCombinedLightness = getCombinedLightness(contentHalfObj.contentHalfBgImageColor, contentHalfBgColor);
            handleContentHalfImageLightnessClass();
          });
        });
      };
    } else {
      contentHalfBgCombinedLightness = getCombinedLightness('rgba(255,255,255,1)', contentHalfBgColor);
      handleContentHalfImageLightnessClass();
    };

    // Fix Safari from constantly loading a new image on Bg picker slider change
    var newContentHalfBgImage = contentHalfBgImage.split('/').pop();
    var oldContentHalfBgImage = contentHalfBgImagePrevious.split('/').pop();

    // Updates the contentHalf background image and background color.
    if (newContentHalfBgImage != oldContentHalfBgImage) {
      $(contentHalf).css({
        'background-image': contentHalfBgImage
      });
    };
    $(contentHalf).find('.background-color').css({
      'background-color': contentHalfBgColor
    });
  };

  var normalizeValue = function (value) {
    if (value == null || (typeof value == 'string' && value.match(/^[\\'"]+$/))) {
      return '';
    } else {
      return value;
    }
  };

  // contentHalf background image and color save logic function.
  var contentHalfBgCommit = function (data, dataName) {
    var commitData = $.extend(true, {}, data);
    commitData.image = data.image || '';
    commitData.imageSizes = normalizeValue(data.imageSizes);
    commitData.color = data.color || 'rgba(255,255,255,0)';
    commitData.combinedLightness = contentHalfBgCombinedLightness;
    if (articlePage) {
      Edicy.articles.currentArticle.setData(dataName, commitData);
    } else {
      pageData.set(dataName, commitData);
    };
  };

  var colorSum = function (bgColor, fgColor) {
    if (bgColor && fgColor) {
      if (typeof bgColor == 'string') {
        bgColor = bgColor.replace(/rgba?\(/, '').replace(/\)/, '').split(',');
        $.each(bgColor, function (n, x) {
          bgColor[n] = +x;
        });
      }
      if (typeof fgColor == 'string') {
        fgColor = fgColor.replace(/rgba?\(/, '').replace(/\)/, '').split(',');
        $.each(fgColor, function (n, x) {
          fgColor[n] = +x;
        });
      }
      if (typeof bgColor == 'object' && bgColor.hasOwnProperty('length')) {
        if (bgColor.length == 3) {
          bgColor.push(1.0);
        }
      }
      if (typeof fgColor == 'object' && fgColor.hasOwnProperty('length')) {
        if (fgColor.length == 3) {
          fgColor.push(1.0);
        }
      }
      var result = [0, 0, 0, 0];
      result[3] = 1 - (1 - fgColor[3]) * (1 - bgColor[3]);
      if (result[3] === 0) {
        result[3] = 1e-6;
      }
      result[0] = Math.min(fgColor[0] * fgColor[3] / result[3] + bgColor[0] * bgColor[3] * (1 - fgColor[3]) / result[3], 255);
      result[1] = Math.min(fgColor[1] * fgColor[3] / result[3] + bgColor[1] * bgColor[3] * (1 - fgColor[3]) / result[3], 255);
      result[2] = Math.min(fgColor[2] * fgColor[3] / result[3] + bgColor[2] * bgColor[3] * (1 - fgColor[3]) / result[3], 255);
      return $.map(result, function (e) {
        return Math.floor(e);
      });
    }
  };

  var getCombinedColor = function (bgColor, fgColor) {
    var sum = colorSum(bgColor || [255, 255, 255, 1], fgColor || [255, 255, 255, 1]);
    return sum;
  };

  var getCombinedLightness = function (bgColor, fgColor) {
    var combinedColor = getCombinedColor(bgColor, fgColor);
    var color = Math.round(((+combinedColor[0]) * 0.2126 + (+combinedColor[1]) * 0.7152 + (+combinedColor[2]) * 0.0722) / 2.55) / 100;
    return color;
  };

  var setImageOrientation = function ($contentItemBox, width, height) {
    var $imgDropAreaTarget = $contentItemBox.find('.js-content-item-img-drop-area'),
      $cropToggleButton = $contentItemBox.find('.js-toggle-crop-state');

    if (width > height) {
      $imgDropAreaTarget
        .removeClass('image-landscape image-square image-portrait')
        .addClass('image-landscape');
    } else if (width === height) {
      $imgDropAreaTarget
        .removeClass('image-landscape image-square image-portrait')
        .addClass('image-square');
    } else {
      $imgDropAreaTarget
        .removeClass('image-landscape image-square image-portrait')
        .addClass('image-portrait');
    }

    if ($imgDropAreaTarget.hasClass('image-square')) {
      $cropToggleButton
        .removeClass('is-visible')
        .addClass('is-hidden');
    } else {
      $cropToggleButton
        .removeClass('is-hidden')
        .addClass('is-visible');
    }
  };

  var setItemImage = function ($contentItemBox, $imgDropArea, itemId, imageId, itemType) {
    var apiType = itemType === 'article' ? 'articles' : 'pages',
      itemData = new Edicy.CustomData({
        type: itemType,
        id: itemId
      });

    $.ajax({
      type: 'PATCH',
      contentType: 'application/json',
      url: '/admin/api/' + apiType + '/' + itemId,
      data: JSON.stringify({
        'image_id': imageId
      }),
      dataType: 'json',
      success: function (data) {
        itemData.set('image_crop_state', 'not-cropped');
        $contentItemBox.removeClass('not-loaded with-error').addClass('is-loaded');
        $contentItemBox.find('.edy-img-drop-area-placeholder').css('opacity', 1);
        $imgDropArea.css('opacity', 1);
      },
      timeout: 30000,
      error: function (data) {
        $contentItemBox.removeClass('not-loaded is-loaded with-error').addClass('with-error');
      }
    });
  };

  var bindContentItemImageCropToggle = function () {
    $('.js-toggle-crop-state').on('click', function () {
      var $contentItemBox = $(this).closest('.js-content-item-box'),
        $imgDropAreaTarget = $contentItemBox.find('.js-content-item-img-drop-area'),
        itemId = $contentItemBox.data('item-id'),
        itemType = $contentItemBox.data('item-type'),
        itemData = new Edicy.CustomData({
          type: itemType,
          id: itemId
        }),
        imageCropState;

      if ($imgDropAreaTarget.hasClass('is-cropped')) {
        $imgDropAreaTarget
          .removeClass('is-cropped')
          .addClass('not-cropped');

        imageCropState = 'not-cropped';
      } else {
        $imgDropAreaTarget
          .removeClass('not-cropped')
          .addClass('is-cropped');

        imageCropState = 'is-cropped';
      }

      itemData.set('image_crop_state', imageCropState);
    });
  };

  // ===========================================================================
  // Load article cover images only when they are close or appearing in the
  // viewport.
  // ===========================================================================
  var bindContentItemImageLazyload = function () {
    $(document).ready(function () {
      setTimeout(function () {
        $('.js-content-item-box').addClass('not-loaded');
      }, 3000);
    });

    $('.js-lazyload').lazyload({
      threshold: 500,
      effect: "fadeIn",
      placeholder: 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==',

      load: function () {
        var $contentItemBox = $(this).closest('.js-content-item-box');

        $contentItemBox.removeClass('not-loaded with-error').addClass('is-loaded');

        setTimeout(function () {
          $contentItemBox.removeClass('not-loaded with-error');
          $contentItemBox.find('.js-loader').remove();
        }, 3000);
      }
    });
  };

  // ===========================================================================
  // Sets functions that will be initiated on items list layouts.
  // ===========================================================================
  var initItemsPage = function () {
    bindContentItemImageLazyload();
  };

  // ===========================================================================
  // Sets header menu initial width attribute for menu mode calculation.
  // ===========================================================================
  var setHeaderMenuInitialWidth = function () {
    var $headerMenu = $('.js-header-menu');

    $headerMenu.attr('data-initial-width', $headerMenu.outerWidth(true));
  };

  // ===========================================================================
  // Toggles product categories visibility in main menu.
  // ===========================================================================
  var bindRootItemSettings = function (rootItemValuesObj) {
    if (!('show_product_related_pages_in_main_menu' in rootItemValuesObj)) {
      rootItemValuesObj.show_product_related_pages_in_main_menu = false;
    }

    $('.js-root-item-settings-toggle').each(function (index, languageMenuSettingsButton) {
      var rootItemSettingsEditor = new Edicy.SettingsEditor(languageMenuSettingsButton, {
        menuItems: [{
          "titleI18n": "show_in_main_menu",
          "type": "checkbox",
          "key": "show_product_related_pages_in_main_menu",
          "states": {
            "on": true,
            "off": false
          }
        }],

        buttonTitleI18n: "settings",

        values: rootItemValuesObj,

        containerClass: ['js-root-item-settings-popover', 'js-prevent-sideclick'],

        preview: function (data) {
          if (!data.show_product_related_pages_in_main_menu === true) {
            $('.js-menu-item-products').addClass('is-hidden');
          } else {
            $('.js-menu-item-products').removeClass('is-hidden');
          }
        },

        commit: function (data) {
          siteData.set('settings_root_item', data);
        }
      });
    });
  };

  // Enables the usage of the initiations outside this file.
  window.template = $.extend(window.template || {}, {
    // Initiations for layouts.
    initItemsPage: initItemsPage,
    
    // Initiations for specific functions.
    bindRootItemSettings: bindRootItemSettings,
    bindContentItemImageCropToggle: bindContentItemImageCropToggle,
    contentHalfBgPreview: contentHalfBgPreview,
    contentHalfBgCommit: contentHalfBgCommit
  });
  
})(jQuery);
